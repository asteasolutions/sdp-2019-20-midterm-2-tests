#include <string>
#include <stack>

/***********************************************************************
  Задача 3. Даден е символен низ, състоящ се от кръгли скоби '(', ')',
  знаците "->" (стрелка) и малки латински букви. Да се реализира
  функция bool valid(const std::string &s, unsigned& error), която
  проверява дали низът, записан в s, е правилно записан типов израз
  съгласно следните правила:

  <променлива> ::= a | b | … | z
  <израз> ::= { <израз> -> } <променлива> | ( <израз> -> <променлива>)

   Ако низът s не е коректен, в параметъра error да се запише индексът
   на първия некоректен символ. В реализацията на valid не е позволено
   използването на рекурсия.

   Пример: "(a->b->b)->b->a->b" е правилно записан израз, но
   "(a->(b)->b)" и "a->b(->c)" не са, като първият грешен символ е
   подчертан.

   Упътване:
   * В стек записваме отварящи скоби, букви, знаците '-' и
   '>', и специален символ (например '?'), означаващ “функционален
   тип, съответстващ на прочетен израз със скоби”.
   * Какво трябва да има на върха на стека при прочитане на '-' и '>'?
   * Какво трябва да се случи със стека при прочитане на '>'?
   * Какво трябва да има на върха на стека при прочитане на ')'?
   * Какво трябва да се случи със стека при прочитане на ')'?
   * Освен случаите на '-', '>' и ')', какви още проверки за
   коректност са нужни? Какво съдържание трябва да има стекът след
   * приключване на програмата?
************************************************************************/

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/

bool isLetter (char c) { return 'a' <= c && c <= 'z'; }
bool isLetterQ(char c) { return isLetter(c) || c == '?'; }

bool valid(const std::string& s, unsigned& error) {
  unsigned& i = error;
  std::stack<char> stack;
  for(i = 0; i < s.size(); ++i)
    if (s[i] == '(') {
      if (!stack.empty() && stack.top() != '>' && stack.top() != '(')
        return false;
      stack.push(s[i]);
    }
    else if (isLetter(s[i])) {
      if (!stack.empty() && stack.top() != '>' && stack.top() != '(')
        return false;
      stack.push(s[i]);
    }
    else if (s[i] == '-') {
      if (stack.empty() || !isLetterQ(stack.top()))
        return false;
      stack.pop();
      stack.push(s[i]);
    }
    else if (s[i] == '>') {
      if (stack.empty() || stack.top() != '-')
        return false;
      stack.push(s[i]);
    }
    else if (s[i] == ')') {
      if (stack.empty() || !isLetter(stack.top()))
        return false;
      stack.pop();
      if (stack.empty() || stack.top() != '>')
        return false;
      while (!stack.empty() && stack.top() != '(')
        stack.pop();
      if (stack.empty())
        return false;
      stack.pop();
      stack.push('?');
    }
    else return false;
  char save;
  if (stack.empty() || !isLetterQ(save = stack.top()))
    return false;
  stack.pop();
  if (!stack.empty() && save == '?')
    return false;
  while (!stack.empty() && (stack.top() == '-' || stack.top() == '>'))
    stack.pop();
  return stack.empty();
}

/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
#include "prob3_tests.h"

int main ()
{
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
