#include <string>
#include <stack>

/***********************************************************************
  Задача 1. Даден е символен низ, състоящ се от кръглите скоби '(',
  ')', запетайки ',' и малки латински букви. Да се реализира функция
  bool valid(const std::string &s, unsigned& error), която проверява
  дали низът, записан в s, е правилно записан функционален израз
  съгласно следните правила:

    <променлива> ::= a | b | … | z
    <израз> ::= <променлива> | <променлива>(<израз>{,<израз>})

  Ако низът s не е коректен, в параметъра error да се запише индексът
  на първия некоректен символ. В реализацията на valid не е позволено
  използването на рекурсия.

  Пример: Например, "f(g(x,y),h(k(u)),v)" е правилно записан израз, но
  "f(g(,x)" и "(f(x),g(y))" не са, като стойността на error е
  съответно 4 и 0.

  Упътване:
    * В стек записваме отварящи скоби, букви и специален символ
    (например '?'), означаващ “резултат от извикването на
    функция”.
    * Какво трябва да има на върха на стека при прочитане на ','?
    * Какво трябва да се случи със стека при прочитане на ','?
    * Какво трябва да има на върха на стека при прочитане на ')'?
    * Какво трябва да се случи със стека при прочитане на ')'?
    * Освен случаите на ',' и ')', какви още проверки за коректност са
    нужни?
    * Какво съдържание трябва да има стекът след приключване на
    програмата?
************************************************************************/

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/

bool isLetter (char c) { return 'a' <= c && c <= 'z'; }
bool isLetterQ(char c) { return isLetter(c) || c == '?'; }

bool valid(const std::string& s, unsigned& error) {
  unsigned& i = error;
  std::stack<char> stack;
  for(i = 0; i < s.size(); ++i)
    if (s[i] == '(') {
      if (stack.empty() || !isLetter(stack.top()))
        return false;
      stack.push(s[i]);
    }
    else if (isLetter(s[i])) {
      if (!stack.empty() && stack.top() != '(')
        return false;
      stack.push(s[i]);
    }
    else if (s[i] == ',') {
      if (stack.empty() || !isLetterQ(stack.top()))
        return false;
      stack.pop();
      if (stack.empty() || stack.top() != '(')
        return false;
    }
    else if (s[i] == ')') {
      if (stack.empty() || !isLetterQ(stack.top()))
        return false;
      stack.pop();
      if (stack.empty() || stack.top() != '(')
        return false;
      stack.pop();
      if (stack.empty() || !isLetter(stack.top()))
        return false;
      stack.pop();
      stack.push('?');
    }
    else return false;
  if (stack.empty() || !isLetterQ(stack.top()))
    return false;
  stack.pop();
  return stack.empty();
}

/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
#include "prob1_tests.h"

int main ()
{
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
